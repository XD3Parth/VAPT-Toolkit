import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import ssl
import socket
import threading
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
from concurrent.futures import ThreadPoolExecutor


class WebPenetrationTester:
    def __init__(self, target_url, log_widget, selected_tests):
        self.target_url = target_url
        self.session = requests.Session()
        self.log_widget = log_widget
        self.selected_tests = selected_tests
        self.results = []

    def log(self, message):
        """Log a message to the GUI."""
        self.log_widget.insert(tk.END, message + "\n")
        self.log_widget.see(tk.END)
        self.results.append(message)

    def get_ip(self):
        """Find the IP address of the target domain."""
        self.log("[*] Resolving IP address...")
        try:
            hostname = self.target_url.replace("https://", "").replace("http://", "").split("/")[0]
            ip = socket.gethostbyname(hostname)
            self.log(f"[+] IP Address of {hostname}: {ip}")
        except Exception as e:
            self.log(f"[-] Error resolving IP: {e}")

    def check_ssl(self):
        """Check SSL/TLS certificate validity."""
        self.log("[*] Checking SSL/TLS...")
        try:
            hostname = self.target_url.replace("https://", "").replace("http://", "").split("/")[0]
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
            self.log(f"[+] SSL/TLS certificate is valid for {hostname}.")
        except Exception as e:
            self.log(f"[-] SSL/TLS issue: {e}")

    def find_forms(self):
        """Find all forms on the page."""
        self.log("[*] Searching for forms...")
        try:
            response = self.session.get(self.target_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all("form")
            self.log(f"[+] Found {len(forms)} forms.")
            return forms
        except Exception as e:
            self.log(f"[-] Error finding forms: {e}")
            return []

    def test_xss(self, form):
        """Test for Cross-Site Scripting (XSS) vulnerabilities."""
        self.log("[*] Testing forms for XSS...")
        xss_payload = "<script>alert('XSS')</script>"
        action = form.get("action")
        post_url = urljoin(self.target_url, action)
        method = form.get("method", "get").lower()
        inputs = form.find_all("input")
        form_data = {input_tag.get("name"): xss_payload for input_tag in inputs if input_tag.get("name")}

        try:
            if method == "post":
                response = self.session.post(post_url, data=form_data)
            else:
                response = self.session.get(post_url, params=form_data)

            if xss_payload in response.text:
                self.log(f"[!] XSS vulnerability found on {post_url}")
                self.log("[*] Exploit: Inject a malicious payload (e.g., `<script>` tags) in form inputs.")
            else:
                self.log(f"[+] No XSS vulnerability on {post_url}")
        except Exception as e:
            self.log(f"[-] Error testing XSS: {e}")

    def test_sql_injection(self, form):
        """Test for SQL Injection vulnerabilities."""
        self.log("[*] Testing forms for SQL Injection...")
        sql_payload = "' OR '1'='1' -- "
        action = form.get("action")
        post_url = urljoin(self.target_url, action)
        method = form.get("method", "get").lower()
        inputs = form.find_all("input")
        form_data = {input_tag.get("name"): sql_payload for input_tag in inputs if input_tag.get("name")}

        try:
            if method == "post":
                response = self.session.post(post_url, data=form_data)
            else:
                response = self.session.get(post_url, params=form_data)

            if "error" in response.text.lower() or "syntax" in response.text.lower():
                self.log(f"[!] SQL Injection vulnerability found on {post_url}")
                self.log("[*] Exploit: Use payloads like `' OR '1'='1` to bypass authentication or extract data.")
            else:
                self.log(f"[+] No SQL Injection vulnerability on {post_url}")
        except Exception as e:
            self.log(f"[-] Error testing SQL Injection: {e}")

    def check_broken_authentication(self):
        """Check for Broken Authentication vulnerabilities."""
        self.log("[*] Checking for Broken Authentication vulnerabilities...")
        test_credentials = [("admin", "admin"), ("admin", "password"), ("user", "password"), ("test", "test")]
        login_page = self.target_url if "/login" in self.target_url else urljoin(self.target_url, "/login")

        for username, password in test_credentials:
            try:
                response = self.session.post(login_page, data={"username": username, "password": password})
                if "dashboard" in response.text.lower() or response.status_code == 200:
                    self.log(f"[!] Broken Authentication found! Login successful with credentials: {username}/{password}")
                    self.log("[*] Exploit: Use the discovered weak credentials to gain unauthorized access.")
                    return
            except Exception as e:
                self.log(f"[-] Error testing authentication: {e}")
        self.log("[+] No Broken Authentication vulnerabilities found.")

    def check_security_headers(self):
        """Check for HTTP security headers."""
        self.log("[*] Checking security headers...")
        try:
            response = self.session.get(self.target_url)
            headers = response.headers
            if "Content-Security-Policy" in headers:
                self.log("[+] Content-Security-Policy is set.")
            else:
                self.log("[-] Missing Content-Security-Policy header.")

            if "X-Frame-Options" in headers:
                self.log("[+] X-Frame-Options is set.")
            else:
                self.log("[-] Missing X-Frame-Options header.")

            if "X-Content-Type-Options" in headers:
                self.log("[+] X-Content-Type-Options is set.")
            else:
                self.log("[-] Missing X-Content-Type-Options header.")
        except Exception as e:
            self.log(f"[-] Error checking security headers: {e}")

    def directory_scanning(self):
        """Scan for common files and directories."""
        self.log("[*] Scanning for common files/directories...")
        common_files = ["admin", "login", "robots.txt", "sitemap.xml", ".git", ".env", "backup", "test"]
        for file in common_files:
            url = urljoin(self.target_url, file)
            try:
                response = self.session.get(url)
                if response.status_code == 200:
                    self.log(f"[!] Found: {url}")
                    self.log("[*] Exploit: Check the discovered file for sensitive information.")
                else:
                    self.log(f"[-] Not found: {url}")
            except Exception as e:
                self.log(f"[-] Error checking {url}: {e}")

    def open_ports_scan(self):
        """Scan for open ports."""
        self.log("[*] Scanning for open ports...")
        hostname = self.target_url.replace("https://", "").replace("http://", "").split("/")[0]
        common_ports = [21, 22, 23, 80, 443, 8080]
        for port in common_ports:
            try:
                with socket.create_connection((hostname, port), timeout=2):
                    self.log(f"[+] Port {port} is open.")
                    self.log("[*] Exploit: Use tools like Nmap or Netcat to interact with open ports.")
            except Exception:
                self.log(f"[-] Port {port} is closed.")

    def run_tests(self):
        """Run selected tests concurrently."""
        self.log(f"[*] Starting tests on {self.target_url}")
        with ThreadPoolExecutor() as executor:
            futures = []
            if "SSL/TLS Check" in self.selected_tests:
                futures.append(executor.submit(self.check_ssl))
            if "Security Headers Check" in self.selected_tests:
                futures.append(executor.submit(self.check_security_headers))
            if "Open Ports Scan" in self.selected_tests:
                futures.append(executor.submit(self.open_ports_scan))
            if "Directory Scanning" in self.selected_tests:
                futures.append(executor.submit(self.directory_scanning))
            if "Broken Authentication Testing" in self.selected_tests:
                futures.append(executor.submit(self.check_broken_authentication))
            
            # Find forms and test for vulnerabilities like XSS and SQLi
            if "XSS Testing" in self.selected_tests or "SQL Injection Testing" in self.selected_tests:
                forms = self.find_forms()
                for form in forms:
                    if "XSS Testing" in self.selected_tests:
                        futures.append(executor.submit(self.test_xss, form))
                    if "SQL Injection Testing" in self.selected_tests:
                        futures.append(executor.submit(self.test_sql_injection, form))
            
            # Wait for all tests to complete
            for future in futures:
                future.result()

        self.get_ip()  # Adding IP fetching functionality
        self.log("[*] Tests completed.")

    def export_results(self):
        """Export results to a text file."""
        file_path = filedialog.asksaveasfilename(defaultextension=".txt",
                                                 filetypes=[("Text Files", "*.txt")])
        if file_path:
            with open(file_path, "w") as f:
                f.write("\n".join(self.results))
            self.log(f"[+] Results saved to {file_path}")


class PenetrationTesterApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced Web Penetration Testing Tool")
        self.root.geometry("900x700")

        # URL Input Frame
        self.frame = ttk.Frame(root, padding="10")
        self.frame.pack(fill=tk.X)

        self.url_label = ttk.Label(self.frame, text="Target URL:")
        self.url_label.pack(side=tk.LEFT, padx=5)

        self.url_entry = ttk.Entry(self.frame, width=60)
        self.url_entry.pack(side=tk.LEFT, padx=5)

        # Test Selection Frame
        self.test_frame = ttk.LabelFrame(root, text="Select Tests", padding="10")
        self.test_frame.pack(fill=tk.X, padx=10, pady=5)

        self.test_vars = {
            "SSL/TLS Check": tk.BooleanVar(),
            "Security Headers Check": tk.BooleanVar(),
            "Open Ports Scan": tk.BooleanVar(),
            "Directory Scanning": tk.BooleanVar(),
            "Broken Authentication Testing": tk.BooleanVar(),
            "XSS Testing": tk.BooleanVar(),
            "SQL Injection Testing": tk.BooleanVar()
        }

        for test, var in self.test_vars.items():
            checkbox = ttk.Checkbutton(self.test_frame, text=test, variable=var)
            checkbox.pack(anchor=tk.W)

        # Log Output Box
        self.log_widget = scrolledtext.ScrolledText(root, width=100, height=20)
        self.log_widget.pack(padx=10, pady=5)

        # Start Button
        self.start_button = ttk.Button(root, text="Start Testing", command=self.start_testing)
        self.start_button.pack(pady=10)

        # Export Results Button
    #    self.export_button = ttk.Button(root, text="Export Results", command=self.export_results)
    #    self.export_button.pack(pady=5)

    def start_testing(self):
        target_url = self.url_entry.get().strip()
        if not target_url:
            messagebox.showerror("Error", "Please enter a target URL.")
            return

        # Select tests based on the associated variables of Checkbuttons
        selected_tests = [test for test, var in self.test_vars.items() if var.get()]

        if not selected_tests:
            messagebox.showerror("Error", "Please select at least one test.")
            return

        tester = WebPenetrationTester(target_url, self.log_widget, selected_tests)
        threading.Thread(target=tester.run_tests).start()

    def export_results(self):
        target_url = self.url_entry.get().strip()
        tester = WebPenetrationTester(target_url, self.log_widget, [])
        tester.export_results()


# Run the Application
if __name__ == "__main__":
    root = tk.Tk()
    app = PenetrationTesterApp(root)
    root.mainloop()
